// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package data

import (
	"context"
	"database/sql"
)

const createJob = `-- name: CreateJob :one
insert into jobs
    (name, notify_log_content)
values (?, ?)
returning id
`

type CreateJobParams struct {
	Name             string
	NotifyLogContent bool
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createJob, arg.Name, arg.NotifyLogContent)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const endRun = `-- name: EndRun :exec
update runs
set end_time = current_timestamp, status = ?
where id = ?
`

type EndRunParams struct {
	Status string
	ID     int64
}

func (q *Queries) EndRun(ctx context.Context, arg EndRunParams) error {
	_, err := q.db.ExecContext(ctx, endRun, arg.Status, arg.ID)
	return err
}

const getJob = `-- name: GetJob :one
select
    jobs.id, jobs.name, jobs.notify_log_content
from jobs
where jobs.name = ?
`

type GetJobRow struct {
	Job Job
}

func (q *Queries) GetJob(ctx context.Context, name string) (GetJobRow, error) {
	row := q.db.QueryRowContext(ctx, getJob, name)
	var i GetJobRow
	err := row.Scan(&i.Job.ID, &i.Job.Name, &i.Job.NotifyLogContent)
	return i, err
}

const getJobs = `-- name: GetJobs :many
select
    jobs.id, jobs.name, jobs.notify_log_content
from jobs
`

type GetJobsRow struct {
	Job Job
}

func (q *Queries) GetJobs(ctx context.Context) ([]GetJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, getJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobsRow
	for rows.Next() {
		var i GetJobsRow
		if err := rows.Scan(&i.Job.ID, &i.Job.Name, &i.Job.NotifyLogContent); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRun = `-- name: GetRun :one
select
    runs.id, runs.job_id, runs.start_time, runs.end_time, runs.log_file, runs.exec_log_file, runs.status, runs.pid,
    jobs.id, jobs.name, jobs.notify_log_content
from runs, jobs
where runs.job_id = jobs.id
and runs.id = ?
`

type GetRunRow struct {
	Run Run
	Job Job
}

func (q *Queries) GetRun(ctx context.Context, id int64) (GetRunRow, error) {
	row := q.db.QueryRowContext(ctx, getRun, id)
	var i GetRunRow
	err := row.Scan(
		&i.Run.ID,
		&i.Run.JobID,
		&i.Run.StartTime,
		&i.Run.EndTime,
		&i.Run.LogFile,
		&i.Run.ExecLogFile,
		&i.Run.Status,
		&i.Run.Pid,
		&i.Job.ID,
		&i.Job.Name,
		&i.Job.NotifyLogContent,
	)
	return i, err
}

const getRuns = `-- name: GetRuns :many
select
    runs.id, runs.job_id, runs.start_time, runs.end_time, runs.log_file, runs.exec_log_file, runs.status, runs.pid,
    jobs.id, jobs.name, jobs.notify_log_content
from runs, jobs
where runs.job_id = jobs.id
and (?1 = '' or jobs.name = ?1)
`

type GetRunsRow struct {
	Run Run
	Job Job
}

func (q *Queries) GetRuns(ctx context.Context, dollar_1 interface{}) ([]GetRunsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRuns, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRunsRow
	for rows.Next() {
		var i GetRunsRow
		if err := rows.Scan(
			&i.Run.ID,
			&i.Run.JobID,
			&i.Run.StartTime,
			&i.Run.EndTime,
			&i.Run.LogFile,
			&i.Run.ExecLogFile,
			&i.Run.Status,
			&i.Run.Pid,
			&i.Job.ID,
			&i.Job.Name,
			&i.Job.NotifyLogContent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isRunFinished = `-- name: IsRunFinished :one
select runs.end_time is not null
from runs
where runs.id = ?
`

func (q *Queries) IsRunFinished(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, isRunFinished, id)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const skipRun = `-- name: SkipRun :one
insert into runs
    (job_id, start_time, end_time, log_file, exec_log_file, status)
values (?, current_timestamp, current_timestamp, "", ?, "Skipped")
returning id
`

type SkipRunParams struct {
	JobID       int64
	ExecLogFile string
}

func (q *Queries) SkipRun(ctx context.Context, arg SkipRunParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, skipRun, arg.JobID, arg.ExecLogFile)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const startRun = `-- name: StartRun :one
insert into runs
    (job_id, start_time, log_file, exec_log_file, status)
values (?, current_timestamp, ?, ?, "Running")
returning id
`

type StartRunParams struct {
	JobID       int64
	LogFile     string
	ExecLogFile string
}

func (q *Queries) StartRun(ctx context.Context, arg StartRunParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, startRun, arg.JobID, arg.LogFile, arg.ExecLogFile)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateJob = `-- name: UpdateJob :exec
update jobs
set name = ?2, notify_log_content = ?3
where id == ?1
`

type UpdateJobParams struct {
	ID               int64
	Name             string
	NotifyLogContent bool
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) error {
	_, err := q.db.ExecContext(ctx, updateJob, arg.ID, arg.Name, arg.NotifyLogContent)
	return err
}

const updateRunPid = `-- name: UpdateRunPid :exec
update runs
set pid = ?2
where id == ?1
`

type UpdateRunPidParams struct {
	ID  int64
	Pid sql.NullInt64
}

func (q *Queries) UpdateRunPid(ctx context.Context, arg UpdateRunPidParams) error {
	_, err := q.db.ExecContext(ctx, updateRunPid, arg.ID, arg.Pid)
	return err
}
